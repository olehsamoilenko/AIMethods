import itertools
import collections
from typing import Callable


class Puzzle:
    """
    A class representing an '8-puzzle'.
    - 'board' should be a square list of lists with integer entries 0...width^2 - 1
       e.g. [[1,2,3],[4,0,6],[7,5,8]]
    """
    def __init__(self, board):
        self.width = len(board[0])
        self.board = board

    @property 
    def actions(self): # TODO: simpler
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'action'.
        """
        def create_move(at, to):
            return lambda: self._move(at, to)

        moves = []
        for i, j in itertools.product(range(self.width),
                                      range(self.width)):
            direcs = {'R':(i, j-1),
                      'L':(i, j+1),
                      'D':(i-1, j),
                      'U':(i+1, j)}

            for action, (r, c) in direcs.items():
                if r >= 0 and c >= 0 and r < self.width and c < self.width and \
                   self.board[r][c] == 0:
                    move = create_move((i,j), (r,c)), action
                    moves.append(move)
        return moves

    def _move(self, at, to): # TODO: simpler
        """
        Return a new puzzle where 'at' and 'to' tiles have been swapped.
        NOTE: all moves should be 'actions' that have been executed
        """
        copy = self.copy()
        i, j = at
        r, c = to
        copy.board[i][j], copy.board[r][c] = copy.board[r][c], copy.board[i][j]
        return copy

    @property
    def solved(self): # TODO: simpler
        """
        The puzzle is solved if the flattened board's numbers are in
        increasing order from left to right and the '0' tile is in the
        last position on the board
        """
        N = self.width * self.width
        return str(self) == ''.join(map(str, range(1,N))) + '0'

    def copy(self): # TODO: simpler
        """
        Return a new puzzle with the same board as 'self'
        """
        board = []
        for row in self.board:
            board.append([x for x in row])
        return Puzzle(board)

    def print(self):
        for i in self.board:
            print(i)
        print()

    def __str__(self): # TODO: remove
        return ''.join(map(str, self))

    def __iter__(self): # TODO: remove
        for row in self.board:
            yield from row


class Node:
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance
    - 'parent' is the preceding node generated by the solver, if any
    - 'action' is the action taken to produce puzzle, if any
    """
    def __init__(self, puzzle, parent=None, action=None):
        self.puzzle = puzzle
        self.parent = parent
        # TODO: mb not needed
        self.action = action
        if (self.parent != None):
            self.g = parent.g + 1
        else:
            self.g = 0

    @property
    def actions(self):
        """ Wrapper for 'actions' accessible at current state """
        return self.puzzle.actions

    @property # TODO: remove
    def solved(self):
        """ Wrapper to check if 'puzzle' is solved """
        return self.puzzle.solved

    @property
    def state(self): # TODO: hash?
        """
        Return a hashable representation of self
        """
        return str(self)

    def print(self):
        self.puzzle.print()

    def __str__(self): # TODO: remove
        return str(self.puzzle)


class Solver:
    """
    A puzzle solver
    """
    def __init__(self, heuristic_function: Callable[[Puzzle], int] = lambda puzzle: 0):
        self._h = heuristic_function

    def solve(self, start: Puzzle):
        queue = collections.deque([Node(start)])
        seen = set()
        seen.add(queue[0].state)
        while queue:
            queue = collections.deque(sorted(list(queue), key=lambda node: node.g + self._h(node.puzzle)))
            node = queue.popleft()
            if node.solved:
                print("Open nodes: %d" % len(seen))
                print("Steps to solve: %d" % node.g)
                return node

            for move, action in node.actions:
                child = Node(move(), node, action)

                if child.state not in seen:
                    queue.appendleft(child)
                    seen.add(child.state)


def wrongplace(puzzle: Puzzle) -> int:
    distance = 0
    for i in range(puzzle.width):
        for j in range(puzzle.width):
            if puzzle.board[i][j] != (puzzle.width * i + j + 1) % puzzle.width ** 2:
                distance += 1
    return distance


def manhattan(puzzle: Puzzle) -> int:
    distance = 0
    for i in range(3):
        for j in range(3):
            if puzzle.board[i][j] != 0:
                x, y = divmod(puzzle.board[i][j]-1, 3)
                distance += abs(x - i) + abs(y - j)
    return distance


if __name__ == '__main__':
    board = [
        [1,2,3],
        [4,5,0],
        [6,7,8]]
    # board = [
    #     [1,2,3],
    #     [4,5,6],
    #     [0,7,8]]

    puzzle = Puzzle(board)
    print("Initial puzzle:")
    puzzle.print()

    print("Dijkstra heuristic function")
    s = Solver()
    p = s.solve(puzzle)
    p.print()

    print("Amount of wrong positioned items heuristic function")
    s = Solver(wrongplace)
    p = s.solve(puzzle)
    p.print()

    print("Manhattan heuristic function")
    s = Solver(manhattan)
    p = s.solve(puzzle)
    p.print()
